## Описание проблемы

![problem](./static/irsene-problem.svg)
Представим себе такую последовательность:
1. Клиентское приложение запрашивает список пользователей запросом к /users и получается пользователей с id от 1 до 10.
2. Пользователь с id 3 меняет свое имя.
3. Клиентское приложение запрашивает пользователя с id 3 с помощью запроса к /user/3.

**Вопрос:** какое имя пользователя с id 3 будет в приложении?<br/>
**Ответ:** зависит от компонента который запросил данные. В компоненте, который использует данные из запроса к /users,
будет отображаться старое имя. В компоненте который использует данные из запроса к /user/3 будет новое имя.

**Вывод**: в таком случае в системе существует несколько одинаковых по смыслу сущностей с разным набором данных. 

**Вопрос:** почему это плохо?<br/>
**Ответ:** в лучшем случае пользователь увидит разные имена в разных разделах сайта, в худшем переведет деньги на старые банковские реквизиты.

## Варианты решения

В настоящее время существуют следующие варианты решения это проблемы:

* Не обращать внимание.
* Нормализовать данные собственноручно.
* Использовать клиент graphql (apollo или relay).

### Не обращать внимание.

Это самые очевидный и заманчивый вариант. В некоторых случаях клиентское приложение действительно может позволить 
себе иметь совпадающие данными сущности. Однако что делать со случаями когда это недопустимое поведение? Как быть с разработчиками которые не хотят создавать приложение с такими дефектами?

### Нормализовать данные собственноручно.

Примером может послужить реализация нормализации c помощью mobx
```js
class Store {
  users = new Map()
  
  async getUsers() {
    const users = await fetch(`/users`)
    users.forEach((user) => this.users.set(user.id, user))
  }
  
  async getUser(id) {
    const user = await fetch(`/user/${id}`)
    this.users.set(user.id, user)
  }
}
```
Работать с таким кодом становится сложнее по мере его увеличения и совсем неинтересно

### Использовать клиент graphql (apollo или relay).

Apollo и relay это библиотеки, которые из коробки умеют нормализовать данные. Однако такое решение 
заставляет использовать нас graphql и apollo, которые, по моему мнению, имеют множеств недостатков

### Нормализация

Что такое нормализация и как она позволяет graphql клиентам бороться с указанной проблемой? Разберемся на примере apollo! 
Так apollo описывает свои действия с данными: 
> ...**normalizes** query response objects before it saves them to its internal data store.

Что включает в себя указанное *normalize*? 
> Normalization involves the following steps:
> 1. The cache generates a unique ID for every identifiable object included in the response.
> 2. The cache stores the objects by ID in a flat lookup table.

То есть apollo формирует уникальный идентификатор для каждой сущности, для которой возможно его сформировать, и 
использует его как ключ в хранилище всех сущностей. Вот как примерно выглядит формирование идентификатора:
```js
const user = {
  id: '0',
  type: 'user',
  name: 'alex',
  age: 24
}

const id = `${user.type}:${user.id}`
```
Комбинация типа и id дает нам по-настоящему уникальный ключ. Мы можем быть уверены, что если встретим другого пользователя 
с таким же типом и id, то это будет тот же пользователь.

Apollo достигает указанного эффекта запрашивая при каждом запросе внутреннее поле __typename, а как достигнуть похожего эффекта без graphql

## iresine



