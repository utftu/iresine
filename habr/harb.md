## Описание проблемы

![problem](./static/irsene-problem.svg)<br/>
Представим себе такую последовательность:
1. Клиентское приложение запрашивает список пользователей запросом к /users и получается пользователей с id от 1 до 10.
2. Пользователь с id 3 меняет свое имя.
3. Клиентское приложение запрашивает пользователя с id 3 с помощью запроса к /user/3.

**Вопрос:** какое имя пользователя с id 3 будет в приложении?<br/>
**Ответ:** зависит от компонента который запросил данные. В компоненте, который использует данные из запроса к /users,
будет отображаться старое имя. В компоненте который использует данные из запроса к /user/3 будет отображаться новое имя.

**Вывод**: в таком случае в системе существует несколько одинаковых по смыслу сущностей с разным набором данных. 

**Вопрос:** почему это плохо?<br/>
**Ответ:** в лучшем случае пользователь увидит разные имена одного человека в разных разделах сайта, в худшем переведет деньги на старые банковские реквизиты.

## Варианты решения

В настоящее время существуют следующие варианты решения это проблемы:

* Не обращать внимание.
* Нормализовать данные собственноручно.
* Использовать клиент graphql (apollo или relay).

### Не обращать внимание.

Это самые очевидный и заманчивый вариант. В некоторых случаях клиентское приложение действительно может позволить 
себе иметь одинаковые сущности с разными данными. Однако что делать со случаями когда это недопустимое поведение? 
Как быть с разработчиками которые не хотят создавать приложение с такими дефектами?

### Нормализовать данные собственноручно.

Примером собственноручной реализации может послужить указанный код для mobx:
```js
class Store {
  users = new Map()
  
  async getUsers() {
    const users = await fetch(`/users`)
    users.forEach((user) => this.users.set(user.id, user))
  }
  
  async getUser(id) {
    const user = await fetch(`/user/${id}`)
    this.users.set(user.id, user)
  }
}
```
Работать с таким кодом становится сложнее по мере его увеличения и совсем неинтересно

### Использовать клиент graphql (apollo или relay).

Apollo и relay это библиотеки, которые из коробки умеют нормализовать данные. Однако такое решение 
заставляет использовать нас graphql и apollo, которые, по моему мнению, имеют множеств недостатков

### Нормализация

Что такое нормализация и как она позволяет graphql клиентам бороться с указанной проблемой? Разберемся на примере apollo! 
Так apollo описывает свои действия с данными: 
> ...**normalizes** query response objects before it saves them to its internal data store.

Что включает в себя указанное *normalize*? 
> Normalization involves the following steps:
> 1. The cache generates a unique ID for every identifiable object included in the response.
> 2. The cache stores the objects by ID in a flat lookup table.

То есть apollo формирует уникальный идентификатор для каждой сущности, для которой возможно его сформировать, и 
использует его как ключ в хранилище всех сущностей. Вот как примерно выглядит формирование идентификатора и его хранение:
```js
const store = new Map()

const user = {
  id: '0',
  type: 'user',
  name: 'alex',
  age: 24
}

const id = `${user.type}:${user.id}`

store.set(id, user)
```
Комбинация типа и id дает нам по-настоящему уникальный ключ. Мы можем быть уверены, что если встретим другого пользователя 
с таким же типом и id, то это будет тот же пользователь.

Apollo достигает указанного эффекта запрашивая при каждом запросе внутреннее поле __typename, а как достигнуть похожего эффекта без graphql?

## iresine

iresine это библиотека, которая создана для нормализации данных и оповещении подписчиков об их изменении.

В данный момент iresine состоит из следующих модулей:
* @iresine/core - основной модуль обрабатывающий данные.
* @iresine/react-query - плагин для react-query. Он позволяет выполнять действия по нормализации напрямую с данными в хранилище react-query. Вся работа происходит автоматически и клиент работает с react-query так, как бы работал без iresine.

![iresine-solve-problem](./static/iresine-solve-problem.svg)

### Получение уникального идентификатора

[comment]: <> (Планы создания новых модулей-оберток:)

[comment]: <> (* @iresine/recoil)

[comment]: <> (* @iresine/swr)

